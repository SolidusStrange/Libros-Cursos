
# 3.6.7 Resumen de Sección – Listas y Slicing

## 1. Asignación entre listas no copia los datos
Si haces `lista_2 = lista_1`, ambas variables apuntan a la misma lista en memoria. Cualquier cambio en una afecta a la otra.

```python
vehículos_uno = ['auto', 'bicicleta', 'moto']
vehículos_dos = vehículos_uno
del vehículos_uno[0]
print(vehículos_dos)  # ['bicicleta', 'moto']
```

## 2. Copiar listas o partes de ellas con slicing
Usar `[:]` crea una copia de la lista completa. También se puede copiar una parte especificando el rango.

```python
colores = ['rojo', 'verde', 'naranja']
copia_total = colores[:]
copia_parcial = colores[0:2]
```

## 3. Uso de índices negativos en slicing
Puedes usar índices negativos para contar desde el final de la lista.

```python
ejemplo = ["A", "B", "C", "D", "E"]
nueva = ejemplo[2:-1]
print(nueva)  # ['C', 'D']
```

## 4. Parámetros de inicio y fin son opcionales en slicing
Puedes omitir el inicio o el final para obtener subconjuntos.

```python
mi_lista = [1, 2, 3, 4, 5]
print(mi_lista[2:])     # [3, 4, 5]
print(mi_lista[:2])     # [1, 2]
print(mi_lista[-2:])    # [4, 5]
```

## 5. Eliminar partes de una lista con `del`
El operador `del` permite eliminar porciones o la lista entera.

```python
lista = [1, 2, 3, 4, 5]
del lista[0:2]
print(lista)  # [3, 4, 5]

del lista[:]
print(lista)  # []
```

## 6. Comprobar existencia con `in` y `not in`
Puedes verificar si un elemento está (o no) en una lista.

```python
datos = ["A", "B", 1, 2]

print("A" in datos)       # True
print("C" not in datos)   # True
print(2 not in datos)     # False
```
